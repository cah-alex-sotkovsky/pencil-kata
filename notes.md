# Feedback

Good job on this.

Good job
how to read this (general comments, commits, suggested changes)

## General Comments

I really appreciated your commit names. Technically they're not 'imperative' ("Do the kata" instead of "Kata works"), but I don't think I do imperative either; I think your commits are just as easy to read / make sense. 

Test names also felt really logical to me, and made it easier to parse through your commits. Again, good job on your attention to detail. Mindfulness like this is such a great way to quickly approve.

It's possible you could write even less comments, but in general I think you did a really good job about being thoughtful with comments and writing them when it was helpful to explain _why_ / intent.

For a while it looks like you weren't formatting (indents etc) but good job catching that and applying those formats.

I love your questions section in the readme. The advice we always give when someone is doing a kata is "where anything is unclear, choose the simplest requirement". 

## Commits

You did a really good job of staying disciplined with commits. A lot of times the beginning is really rough for people because they want to throw in a bunch of initial code. I also often see people just give up halfway through. Way to stay disciplined throughout.

The main area I'd work on improving in the next kata, from a commit perspective, is isolated tests. If you have one or more commits that is test only, that can indicate that you wrote more code than needed to make an earlier test pass, or that earlier test was too broadly scoped.

c2551c2bea3c5212c903b2efc81e25d088a5156c
- This guy is a funky commit; looks like some autogenerated stuff that doesn't compile?
- It's really tempting to model out all your objects before you start writing tests, and that's very OO to do. That said, often you don't know how your models will turn out (for instance your moving functionality to pencil from paper). Good job at creating just the top level object and not adding methods or variables to them before they are needed.

432ffb2a0b90f5af640d1c0d592751a01af07d7b
- Looks like you fixed all the funkiness from the previous commit.
- Looks like two tests here. I'm guessing the first commit was kind of a bad commit and you caught it when you wrote the second test?

a9855c8
- Looks like a good refactor here, but we also lost the append test?
- What does `assertNotEquals("Goodbye", paper.getText());` do for us?

20bef3f
- Nice, we redid the append test in a cleaner way

6603934
- We added a new test, but it isn't really testing durability. Instead, the existing test is doing that. In general we want to use existing tests as a regression / net, and create new tests for the new function. How could we have kept the existing test the same and created a new one that would test durability?
- This is valuable because when something breaks, the (failing) test name alone should point us at what piece of code we've broken. We'd want the durability test to fail if we, say, had the wrong default durability
- This durability test depends on a default. It's nice to be explicit when we're testing a feature, as then changing the default is less likely to break tests later on
- Looks like the next test gets that piece

c72ef86
- Do we need a setter for durability? What if that (and max durability) were only set on initialization
- The lest moving parts we have, the less bugs are possible (immutability)

8b96b9c
- Hardcore TDD would say you should never add a test that doesn't force you to write code, because the test is redundant. I personally think there is still value to call out an edge case, even if an early test forced the proper code into place
- I chuckled out loud when I saw this commit is where we added the readme.
- Super cautious devs would have had the resume pristine in their first commit
- Your style seems more similar to mine (and a good fit for this team): we want to get that core functionality in and working before we do documentation
- Either style is just a starting bias. Since we're similar in this aspect, we'll just need to be more consciously cautious until we get a more caution-biased teammate.

a751cf5
- When you've seen a number of commits where you can write a test and the code is already implemented, that's a smell that you may have written too much code to pass an earlier test. It doesn't mean that you have, but that it's worth thinking about
- It looks to me like you were thinking ahead with the eraser class, probably after feeling confident based on what you did with the pencil class. You can also get into this if you reuse code and it solves a number of use cases etc

a5bdfd1e13a2755d8173fb3221b0d855ce915f4f
- I'm curious why this test changed from the previous commit, but no implementation changed?
- Seems like all the nearby commits pass...

03f5320
- There's always a big refactor commit like this
- Hypothetically you could possibly break this into smaller commits for the new test and for refactoring the old, but I know as you work through this it can come kind of together. There are some staging techniques you can use to make it 'look' more like you knew exactly what you were doing; we can talk about them some time
- looks like this guy has an extra `}` as well and so doesn't compile?
